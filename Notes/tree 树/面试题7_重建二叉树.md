# é¢è¯•é¢˜ 7ï¼šé‡å»ºäºŒå‰æ ‘

---

[leetcode-cn é¢˜ç›®åœ°å€](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

ğŸ“—difficultyï¼š**Medium** 

ğŸ¯Tagsï¼š

+ **[é€’å½’](https://leetcode-cn.com/tag/recursion/)**
+ **[æ ‘](https://leetcode-cn.com/tag/tree/)**

---

## 1. é¢˜ç›®æè¿°ğŸ“ƒ

è¾“å…¥æŸäºŒå‰æ ‘çš„å‰åºéå†å’Œä¸­åºéå†çš„ç»“æœï¼Œè¯·é‡å»ºè¯¥äºŒå‰æ ‘ã€‚

å‡è®¾è¾“å…¥çš„å‰åºéå†å’Œä¸­åºéå†çš„ç»“æœä¸­éƒ½ä¸å«é‡å¤çš„æ•°å­—ã€‚

ä¾‹å¦‚ï¼Œç»™å‡º

+ å‰åºéå† preorder = `[3,9,20,15,7]`
+ ä¸­åºéå† inorder = `[9,3,15,20,7]`

è¿”å›å¦‚ä¸‹çš„äºŒå‰æ ‘ï¼š

![](https://assets.ryantech.ltd/20200501154907.png)

æ³¨æ„ï¼šæœ¬é¢˜ä¸ä¸»ç«™ 105 é¢˜é‡å¤ï¼šhttps://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/



## 2. è§£é¢˜æ€è·¯ğŸ’¡

åœ¨äºŒå‰æ ‘çš„å…ˆåºéå†ä¸­ï¼Œç¬¬ä¸€ä¸ªæ•°å­—æ€»æ˜¯æ ‘çš„æ ¹èŠ‚ç‚¹çš„å€¼ã€‚

ä½†æ˜¯åœ¨ä¸­åºéå†çš„åºåˆ—ä¸­ï¼Œæ ¹èŠ‚ç‚¹çš„å€¼åœ¨åºåˆ—çš„ä¸­é—´ï¼Œè€Œä¸”å·¦å­æ ‘çš„èŠ‚ç‚¹çš„å€¼ä½äºæ ¹èŠ‚ç‚¹çš„å·¦è¾¹ï¼Œå³å­æ ‘çš„èŠ‚ç‚¹çš„å€¼ä½äºæ ¹èŠ‚ç‚¹çš„å³è¾¹ã€‚è€Œé¢˜ç›®æè¿°ä¸­æœ‰â€œä¿è¯å…¨éƒ¨çš„èŠ‚ç‚¹å€¼ä¸é‡å¤â€ï¼Œéå†ä¸€æ¬¡ä¸­åºéå†çš„åºåˆ—ï¼Œå°±èƒ½æ‰¾åˆ°æ ¹èŠ‚ç‚¹çš„å€¼åœ¨ä¸­åºéå†åºåˆ—ä¸­çš„ä½ç½®ã€‚

å¯¹äºä¸‹é¢çš„è¿™ä¸ªæ ‘ï¼š

+ å…ˆåºéå†åºåˆ—ï¼š`{1, 2, 4, 7, 3, 5, 6, 8}`
+ ä¸­åºéå†åºåˆ—ï¼š`{4, 7, 2, 1, 5, 3, 8, 6}`

![](https://assets.ryantech.ltd/20200501170146.png)

å¯ä»¥æ ¹æ®ä¸Šè¿°åˆ†æï¼Œå¾—åˆ°ä¸‹é¢è¿™ä¸ªç»“è®ºï¼š

![](https://assets.ryantech.ltd/20200501170335.png)

é‚£ä¹ˆè·å¾—äº†å·¦å­æ ‘å’Œå³å­æ ‘ä¹‹åï¼Œå¯ä»¥ç”¨åŒæ ·çš„æ–¹æ³•æ¥æ„å»ºå·¦å­æ ‘çš„å·¦ã€å³å­æ ‘ï¼Œå³ä½¿ç”¨é€’å½’çš„æ€æƒ³æ¥å®Œæˆã€‚

å¯¹äºé€’å½’ï¼Œå…³é”®åœ¨äºæ‰¾å‡ºå…¶é€’å½’ç»ˆæ­¢çš„æ¡ä»¶ã€‚

å¯¹äºæœ¬é¢˜æ¥è¯´ï¼Œæœ‰ä»¥ä¸‹ 2 ä¸ªç»ˆæ­¢çš„æ¡ä»¶ï¼š

+ å½“ start æŒ‡é’ˆå¤§äº end æŒ‡é’ˆæ—¶ï¼Œæ„å‘³ç€æ²¡æœ‰èŠ‚ç‚¹ï¼Œè¿”å› null
+ å½“ start æŒ‡é’ˆç­‰äº end æŒ‡é’ˆæ—¶ï¼Œæœ‰ä¸”åªæœ‰`æ ¹èŠ‚ç‚¹` ï¼Œè¿”å›è¯¥èŠ‚ç‚¹

å…¶ä»–æƒ…å†µï¼Œåˆ™è¯´æ˜æœ‰å·¦å­æ ‘å’Œå³å­æ ‘çš„æƒ…å†µï¼Œç»§ç»­é€’å½’å¤„ç†å³å¯ã€‚

æ ¹æ®ä¸Šè¿°é€»è¾‘ï¼Œå¯ä»¥ç¼–å†™ä»¥ä¸‹ä»£ç ï¼š

```java
public TreeNode buildTree(int[] preorder, int[] inorder) {
    if (preorder == null || preorder.length == 0) {
        return null;
    }
    Map<Integer, Integer> indexMap = new HashMap<>();
    int length = preorder.length; // æ ‘ä¸­çš„èŠ‚ç‚¹æ•°é‡ä¸éå†æ–¹å¼æ— å…³
    for (int i = 0; i < length; i++) {
        indexMap.put(inorder[i], i);
    }
    TreeNode root = buildTree(preorder, 0, length - 1,
                              inorder, 0, length - 1,
                              indexMap);
    return root;
}

public TreeNode buildTree(int[] preorder, int preorderStart, int preorderEnd,
                          int[] inorder, int inorderStart, int inorderEnd,
                          Map<Integer, Integer> indexMap) {
    if (preorderStart > preorderEnd) {
        // é€’å½’ç»“æŸæƒ…å½¢ 1 : å…ˆåºéå†çš„å¼€å§‹èŒƒå›´å¤§äºç»“æŸèŒƒå›´ï¼Œæ­¤æ—¶è¡¨ç¤ºäºŒå‰æ ‘ä¸­æ²¡æœ‰èŠ‚ç‚¹
        return null;
    }

    int rootVal = preorder[preorderStart]; // å…ˆåºéå†çš„æƒ…å†µä¸‹ï¼Œç¬¬ä¸€ä¸ª index å¤„ä¸ºæ ¹èŠ‚ç‚¹
    TreeNode root = new TreeNode(rootVal);
    if (preorderStart == preorderEnd) {
        // é€’å½’ç»“æŸæƒ…å½¢ 2 : å¼€å§‹ç­‰äºç»“æŸï¼Œæ„å‘³ç€å½“å‰äºŒå‰æ ‘ä¸­åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œä»¥è¯¥èŠ‚ç‚¹å€¼åˆ›å»ºæ ¹èŠ‚ç‚¹å¹¶è¿”å›
        return root;
    } else {
        int rootIndex = indexMap.get(rootVal);
        int leftNodes = rootIndex - inorderStart;
        int rightNodes = inorderEnd - rootIndex;
        // å·¦å³å­æ ‘çš„æ„å»º
        // æ³¨æ„å…ˆåºå’Œä¸­åºçš„ä¸‹æ ‡ä½ç½®
        TreeNode leftSubtree = buildTree(preorder, preorderStart + 1, preorderStart + leftNodes,
                                         inorder, inorderStart, rootIndex - 1,
                                         indexMap);
        TreeNode rightSubtree = buildTree(preorder, preorderEnd - rightNodes + 1, preorderEnd,
                                          inorder, rootIndex + 1, inorderEnd,
                                          indexMap);
        root.left = leftSubtree;
        root.right = rightSubtree;
        return root;
    }
}
```

ä¸Šè¿°ä»£ç é€»è¾‘æ¥è‡ªäº [leetcode-cn å®˜æ–¹é¢˜è§£](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-by-leetcode-s/)ã€‚

#### å¤æ‚åº¦åˆ†æ

+ æ—¶é—´å¤æ‚åº¦ï¼š`O(n)`
+ ç©ºé—´å¤æ‚åº¦ï¼š`O(n)`



### ç®€åŒ–ç‰ˆæœ¬

ä¸Šè¿°ä»£ç çš„ä»£ç æœ‰äº›å†—é•¿ï¼Œä½†å…¶æ€è·¯è¾ƒä¸ºæ¸…æ™°ï¼Œé…åˆå›¾ç¤ºå·²äºç†è§£ã€‚

ä¸‹è¿°ä»£ç æ›´åŠ ç®€æ´ï¼Œæ›´åŠ æ˜¾ç¤ºäº†é€’å½’è§£æ³•çš„ç®€æ´æ€§ã€‚

```java
class Solution {
    HashMap<Integer, Integer> dic = new HashMap<>();
    int[] po;
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        po = preorder;
        for(int i = 0; i < inorder.length; i++) 
            dic.put(inorder[i], i);
        return recur(0, 0, inorder.length - 1);
    }
    TreeNode recur(int pre_root, int in_left, int in_right) {
        if(in_left > in_right) return null;
        TreeNode root = new TreeNode(po[pre_root]);
        int i = dic.get(po[pre_root]);
        root.left = recur(pre_root + 1, in_left, i - 1);
        root.right = recur(pre_root + i - in_left + 1, i + 1, in_right);
        return root;
    }
}
```

#### å¤æ‚åº¦åˆ†æ

+ æ—¶é—´å¤æ‚åº¦ï¼š
    + O(N) ã€‚N ä¸ºæ ‘çš„èŠ‚ç‚¹æ•°é‡ã€‚åˆå§‹åŒ– HashMap éœ€éå† inorder ï¼Œå ç”¨ O(N) ï¼›é€’å½’å…±å»ºç«‹ N ä¸ªèŠ‚ç‚¹ï¼Œæ¯å±‚é€’å½’ä¸­çš„èŠ‚ç‚¹å»ºç«‹ã€æœç´¢æ“ä½œå ç”¨ O(1) ï¼Œå› æ­¤é€’å½’å ç”¨ O(N) ã€‚ï¼ˆæœ€å·®æƒ…å†µä¸ºæ‰€æœ‰å­æ ‘åªæœ‰å·¦èŠ‚ç‚¹ï¼Œæ ‘é€€åŒ–ä¸ºé“¾è¡¨ï¼Œæ­¤æ—¶é€’å½’æ·±åº¦ O(N) ï¼›å¹³å‡æƒ…å†µä¸‹é€’å½’æ·±åº¦å¹³å‡æƒ…å†µä¸‹é€’å½’æ·±åº¦ O(log2 N)ï¼‰ã€‚

+ ç©ºé—´å¤æ‚åº¦ï¼šO(N) ã€‚HashMap ä½¿ç”¨ O(N) é¢å¤–ç©ºé—´ï¼›é€’å½’æ“ä½œä¸­ç³»ç»Ÿéœ€ä½¿ç”¨ O(N) é¢å¤–ç©ºé—´ã€‚

## 3. æ€»ç»“ğŸ¯

å¯¹äºæ ‘çš„é¢˜ç›®ï¼Œå¾ˆå¤šæ—¶å€™é‡ç‚¹è€ƒå¯Ÿå¯¹é€’å½’çš„ç†è§£å’Œç†Ÿç»ƒæŒæ¡çš„ç¨‹åº¦ã€‚

æ ‘çš„çŸ¥è¯†ä¸­ï¼Œå¾ˆé‡è¦çš„ä¸€ä¸ªéƒ¨åˆ†æ˜¯æ ‘çš„éå†ï¼Œå…¶ä¸­åˆè€ƒå¯Ÿåˆ°å¯¹é€’å½’çš„ç†è§£ã€‚æ ‘çš„éå†æœ‰å¾ˆå¼ºçš„è§„å¾‹æ€§ï¼Œå³ç‰¹ç‚¹ã€‚ä¾‹å¦‚åœ¨æœ¬é¢˜ä¸­ï¼Œå…ˆåºéå†çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹ï¼Œè¿™ä¸ªç‰¹æ€§è¢«ç”¨äºè§£é¢˜ï¼Œå¦‚æœå¯¹æ ‘çš„éå†çš„ç‰¹ç‚¹æŒæ¡ä¸å¥½ï¼Œéš¾ä»¥è§£å‡ºæ­¤é¢˜ã€‚