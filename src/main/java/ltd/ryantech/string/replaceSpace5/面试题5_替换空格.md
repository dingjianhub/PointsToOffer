# 面试题 5 ：替换空格

---

[leetcode-cn 题目地址](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)

📗difficulty：**Easy** 

🎯Tags：

+ **[字符串](https://leetcode-cn.com/tag/string/)**

---

## 1. 题目描述📃

请实现一个函数，把字符串 `s` 中的每个空格替换成 "`%20`" 。 

样例：

输入：`s = "We are happy."`
输出：`"We%20are%20happy."`

+ 能做到在 `O(n)` 时间复杂度内完成吗？



## 2. 解题思路💡

我们假定这样的字符串是以字符数组的形式存储下来的。在 Java 中，即为 `char[]` 。

一种思路是从前向后处理，由于数组的特性，对于插入操作，需要搬迁数据，这会带来很高的复杂度。

对于一个空格来说，对其进行处理，需要搬迁后面 `O(n)` 个字符，对于含有 `O(n)` 个空格字符的字符串，总的时间复杂度为 `O(n ^ 2)` 。这样的代价是很高的。

如果换一种思路，从后先前进行处理呢？

首先，对于一个空格字符来说，将其置换为 `%20` ，需要额外的 2 个空间，那么最后的数组长度就需要增加 `n * 2` 个空间。而空格字符的总量，一次遍历即可，复杂度为 `O(n)` 。

设置 2 个指针，一个指针为 p，指向扩容前的最后一个字符，这里的字符数组长度以及扩充为 `len(chars) + n * 2` 了。一个指针为 q，指向扩容后的字符数组尾部。p 每次向前一个位置，如果字符不为空格，q 直接覆写 p 当前所指字符，`q--`；遇到空格，则写入 `%20` ，`q = q - 3`。这样将复杂度下降为 `O(n)` 。

```java
public String replaceSpace(String s) {
    // 按照书本的思路指示，处理 s 按照 array 的方式来处理
    if (s == null || s.length() == 0) {
        return "";
    }

    int spaceCount = 0;
    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i) == '\u0020') { // 空格的 Unicode 编码
            spaceCount++;
        }
    }

    char[] chars = new char[s.length() + 2 * spaceCount];
    int p = s.length() - 1;
    int q = chars.length - 1;
    while (p >= 0) {
        if (s.charAt(p) != '\u0020') {
            chars[q] = s.charAt(p);
            q--;
        } else {
            chars[q] = '0';
            chars[q - 1] = '2';
            chars[q - 2] = '%';
            q = q - 3;
        }
        p--;
    }
    return String.valueOf(chars);
}
```

这里按照《剑指Offer》中给定的描述，输入为一个字符数组的形式。那么可以获得如下的复杂度。

+ 时间复杂度
    + `O(n)`
+ 空间复杂度
    + `O(1)` 

## 3. 总结🎯

数组的覆写具有一定的特性，修改其中的数据可能会需要大量的数据搬迁。

某些情况下，可以利用给定数组的特殊性质和操作情况，灵活进行操作。例如本道题目的情况，从后向前进行覆写，达到优化时间复杂度的目标。

### 扩展题目

![排序数组合并](https://assets.ryantech.ltd/20200825160825.png)

依然使用从后向前的思路进行操作。**注意最后处理剩余的数组元素。**

```java
public void insert(int[] a1, int size, int[] a2) {
    int fullsize = size + a2.length;
    int p = size - 1;
    int q = fullsize - 1;
    int z = a2.length - 1;
    while (p >= 0 && z >= 0) {
        if (a1[p] >= a2[z]) {
            a1[q--] = a1[p--];
        } else {
            a1[q--] = a2[z--];
        }
    }
    while (p >= 0) {
        a1[q--] = a1[p--];
    }
    while (z >= 0) {
        a1[q--] = a2[z--];
    }
}
```

#### 举一反三

在合并两个数组（包括字符串）时，如果从前往后复制每个数字（或字符）则需要重复移动数字（或字符）多次，那么我们可以考虑从后往前复制，这样可以减少移动的次数，从而提高操作的效率。



### 本题考点

+ 考察应聘者对字符串的编程能力。
+ 考察应聘者分析时间效率的能力。需要面试者能够清楚地计算不同算法的时间复杂度是多少。
+ 考察应聘者对于内存覆盖是否具有很高的敏感性和高度的警惕性。在得知需要对字符串进行扩容的情况下，明白可能存在的问题，和面试官积极地进行沟通。
+ 考察应聘者的思维能力。从初始的：从前向后替换的思路被否定，能否有反向思路，从后向前进行替换，这才是解决本题的关键所在。