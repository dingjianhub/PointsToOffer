# 面试题 55_2 ：平衡二叉树

---

[leetcode-cn 题目地址](https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/)

📗difficulty：**Easy**	

🎯Tags：

+ **[哈希表](https://leetcode-cn.com/tag/hash-table/)** 
+ **[深度优先搜索](https://leetcode-cn.com/tag/depth-first-search/)**



---

## 1. 题目描述📃

输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。



**样例 1 ：**

给定二叉树 `[3,9,20,null,null,15,7]`

```
 	3
   / \
  9  20
    /  \
   15   7
```

返回 `true` 。



**样例 2 ：**

给定二叉树 `[1,2,2,3,3,null,null,4,4]`

```
 	   1
      / \
     2   2
    / \
   3   3
  / \
 4   4
```

返回 `false`。



**注意：**

+ `1 <= 树的结点个数 <= 10000`



注意：本题与主站 110 题相同：https://leetcode-cn.com/problems/balanced-binary-tree/

---

## 2. 解题思路💡

> 以下思路来源于 [leetcode-cn 用户 Krahets 的题解](https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/solution/mian-shi-ti-55-ii-ping-heng-er-cha-shu-cong-di-zhi/)，感谢他的精彩分析。

### 从顶到底 逐棵树检查





#### 代码实现

```java
// 存在大量的重复计算 depth
public boolean isBalanced(TreeNode root) {
    if (root == null) {
        return true;
    }
    // 对每棵子树递归检查是否平衡
    return Math.abs(depth(root.left) - depth(root.right)) <= 1 && isBalanced(root.left) && isBalanced(root.right);
}

// 获取树的最大深度
public int depth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    return Math.max(depth(root.left), depth(root.right)) + 1;
}
```





#### 复杂度分析

+ 时间复杂度：`O(1)`    `O(log n)`      `O(n)`      `O(n log n)`  `O(n ^ 2)`。
+ 空间复杂度：`O(1)`    `O(log n)`     `O(n)` 。





---

## 3. 总结🎯

