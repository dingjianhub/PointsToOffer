# 面试题 ：

---

[leetcode-cn 题目地址](https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/)

📗difficulty：**Easy**	

🎯Tags：

+ **[数学](https://leetcode-cn.com/tag/math/)**
+ **[位运算](https://leetcode-cn.com/tag/bit-manipulation/)**
---

## 1. 题目描述📃

请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 `9` 表示成二进制是 `1001`，有 `2` 位是 `1`。因此，如果输入 `9`，则该函数输出 `2`。

**样例 1 ：**

```
输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
```

**样例 2 ：**

```
输入：00000000000000000000000010000000
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
```

**示例 3：** 

```
输入：11111111111111111111111111111101
输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
```

**注意：**

+  本题与主站 191 题相同：https://leetcode-cn.com/problems/number-of-1-bits/ 

## 2. 解题思路💡

### 掩码位运算

题目中给定是 int 类型，在 Java 中其长度为 32，那么需要遍历 32 位。如果某一位为 1，那么将 `res` 加一。

任意一个数字和 1 相与操作后，例如 `m & 1` 后，其值有一定的规律：

```
1:	0000 0000 0000 0000 0000 0000 0000 0001
n:	0010 0110 0110 1100 0010 0110 0000 0001
```

对上面 2 个数进行与操作后，如果其结果大于 1，这说明 n 的最低位数字为 1，否则为 0 。

将数字 1 左移动 1 位，得到如下：

```
1:	0000 0000 0000 0000 0000 0000 0000 0010
n:	0010 0110 0110 1100 0010 0110 0000 0001
```

如果其与的结果，大于 1，说明 n 的倒数第二位上的数字其值为 1，否则为 0。

#### 代码实现

```java
// you need to treat n as an unsigned value
// 掩码做法
public int hammingWeight(int n) {
    int res = 0;
    int mask = 1;
    for (int i = 0; i < 32; i++) {
        if ((n & mask) != 0) {
            res++;
        }
        mask = mask << 1;
    }
    return res;
}
```

#### 复杂度分析

+ 时间复杂度：`O(1)`，本题输入为 int 32位长度的情况下，其整体复杂度为 `O(1)`。
+ 空间复杂度：`O(1)`。



以下[思路分析来自 leetcode-cn](https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/solution/mian-shi-ti-15-er-jin-zhi-zhong-1de-ge-shu-wei-yun/) 用户 [Krahets](https://leetcode-cn.com/u/jyd/) ，在此表示感谢。

### 循环逐位判断

+ 根据 与运算 定义，设二进制数字 n ，则有：
    + 若 n \& 1 = 0 ，则 n 二进制 最右一位 为 0 ；
    + 若 n \& 1 = 1 ，则 n 二进制 最右一位 为 1 。
+ 根据以上特点，考虑以下 **循环判断** ：
    + 判断 n 最右一位是否为 1 ，根据结果计数。
    + 将 n 右移一位（本题要求把数字 n 看作无符号数，因此使用 无符号右移 操作）。

#### 代码实现

```java
// you need to treat n as an unsigned value
public int hammingWeight(int n) {
    int res = 0;
    while (n != 0) {
        if ((n & 1) == 1) {
            res++;
        }
        n = n >>> 1; // 无符号右移
    }
    return res;
}
```

#### 复杂度分析

+ 时间复杂度：`O(log n)`，但是本题输入为 int 32 位长度的情况下，其整体复杂度为 `O(1)`。
+ 空间复杂度：`O(1)`。



### 巧用 `n & (n - 1)`

+ (n−1) 解析： 二进制数字 n 最右边的 1 变成 0 ，此 1 右边的 0 都变成 1 。
+ n \& (n - 1) 解析： 二进制数字 n 最右边的 1 变成 0 ，其余不变。

![n & (n - 1)](https://assets.ryantech.ltd/20200512143742.png)

```java
// 每次消去 n 最右边的 1，消除几次就有几个 1
public int hammingWeight(int n) {
    int res = 0;
    while (n != 0) {
        res++;
        n = n & (n - 1);
    }
    return res;
}
```

#### 复杂度分析

+ 时间复杂度：`O(M)`，但是本题输入为 int 32 位长度的情况下，其整体复杂度为 `O(1)`。
+ 空间复杂度：`O(1)`。

## 3. 总结🎯

相同的题目：[191. 位 1 的个数](https://leetcode-cn.com/problems/number-of-1-bits/)

以下分析来自于 [cnblogs 用户](https://www.cnblogs.com/wangmingshun/p/5398712.html)，表示感谢。

### Java 的运算符： 与，或，非，异或 详解

#### 与 &

